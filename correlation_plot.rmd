---
title: "Correlation plot"
author: "Paige, Vicky, and Jackie"
date: '2019-11-10'
output: 
  prettydoc::html_pretty:
  theme : cayman
  highlight : github
  math: katex
---

# Loading libraries
```{r}
library(ggplot2)
library(reshape2) # Used for the melt function
```

#load data

```{r}
library(dplyr)# Load the data
cd <- read.csv(file = "cleanData.csv", header = TRUE, sep = ",", 
                stringsAsFactors = T)

print("ORIGIN DATA")

summary(cd)
```

# Getting correlations
```{r}
# Method used to get 'correlation' for categorical variables
# https://datascience.stackexchange.com/questions/893/how-to-get-correlation-between-two-categorical-variable-and-a-categorical-variab#898

# All column types in cd are either factors (categorical), 
# or numerical (including integers)
unlist(lapply(cd, class))

# Calculate correlation for dataframe with categorical and numerical variables
categorical_cor <- function(column1, column2){
    if( class(column1) == "factor" &&
        (class(column2) == "numeric" || class(column2) == "integer")
    ){  # Swap the columns; I think this is having issues, I will just try
        # call the function again, but with swapped columns
        # temp_column = column1
        # column1 = column2
        # column2 = temp_column
        # rm(temp_column)
        categorical_cor(column2, column1)
    } # Columns should be numerical/integer, then factor
    # else if(column1 == column2){
    #     # Hard coding a correlation of 1 if both columns are the same
    #     return(1)
    # }
    else{
        if( # Use chi squared if class(column) == factor for both
            (class(column1) == "factor") &&
            (class(column2) == "factor")
        ){
            # Not sure if correct needs to be equal to F, 
            # but the link shows it
            
            # https://www.r-bloggers.com/example-8-39-calculating-cramers-v/
            cramers_v = sqrt(chisq.test(column1, column2, 
                                        correct = F)$statistic / 
                                 (length(column1) * 
                                      ( min(length(unique(column1)), 
                                           length(unique(column2))) - 1 )))
            return(as.numeric(cramers_v))
            #return(chisq.test(column1, column2, correct = F)$p.value)
        }
        else if( # Use corr if class(column) == numerical or integer for both
            ( (class(column1) == "numeric") ||
            (class(column1) == "integer") ) &&
            ( (class(column2) == "numeric") ||
            (class(column2) == "integer") )
        ){
            cor(column1, column2)
        }
        else if( # Use the p-value from aov if the columns are a mix
            (class(column1) == "numeric" || class(column1) == "integer") &&
            class(column2) == "factor"
        ){
            summary_table <- summary(aov(column1 ~ column2))
            return(summary_table[[1]][[5]][1]) # This should return the p-value
        }
        else{ # Return this message if at least one of the columns
            # is a different class than factor, numerical or integer
            return("error, 
                   class(column) must be factor, numerical, or integer")
        }
    }
}

# Create an empty data frame to store all the correlation values
cd.cor <- cbind(expand.grid("Column_1" = colnames(cd), 
                            "Column_2" = colnames(cd)), "Corr" = 0)
# Add the correlation values
# Find a way to fill the "Corr" column with values from the custom function

```

# Create correlation plot matrix
```{r}
head(cd.cor$Column_1)

# Example of using the map function
df1 <- data.frame("Col_1" = c(1, 1, 2, 2, 3, 3), 
                  "Col_2" = c("r", "r", "b", "b", "y", "y"))

categorical_cor(df1$Col_1, df1$Col_2)

# For each row of cd.cor

# Use the function on two columns; the column names are obtained from
# the first two columns of cd.cor

for(i in c(1:529)){
    cd.cor[i, 3] <- categorical_cor(cd[[ cd.cor[i, 1] ]], 
                                    cd[[ cd.cor[i, 2] ]])
    
}

# Link to code involving the chi-squared test code
# https://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
# Link to explanation of formula
# https://www.spss-tutorials.com/cramers-v-what-and-why/

# Pearson's chi-squared test (Ï‡2) is a statistical test applied to sets of 
# categorical data to evaluate how likely it is that any observed 
# difference between the sets arose by chance
```

Testing a correlation ratio algorithm
```{r}
# Creating a test to try the algorithm
df2 <- data.frame(score = c(45, 70, 29, 15, 21, 40, 20, 30, 42, 65, 95, 80, 70, 85, 73), 
                  subject = c(rep("Algebra", times = 5),
                              rep("Geometry", times = 4),
                              rep("Statistics", times = 6)
                              )
                  )

# Using str, we can see that the subject category has factors just like
# the original data frame
str(df2$subject)
# This should be numeric or integer
class(df2$score)
om <- mean(df2$score)



summ_2 <- group_by(df2, subject) %>%
    summarise(avg = mean(score),
              ss1 = sum(score - avg)^2, ss2 = sum(score - om)^2)

## Creating a function that will handle this
# Function takes two columns, one categorical, one numerical,
# and computes the correlation
mixed_cor <- function(column1, column2){
    # Checking that the dplyr library is loaded
    library(dplyr)
    
    # This function accepts two columns, one has to be numerical/integer, the
    # other must be categorical (factor type)
    
    # This function assumes no NAs
    
    # Check that column1 is numerical, and column2 is factor in that order
    # if not, use this same function with the arguments swapped
    if(class(column1) == "factor"){
        mixed_cor(column2, column1)
    }
    else{ # For each factor in the categorical column
        for(i in c(1:length( levels(factor(column2)) )) ){
            categorical_means = c(categorical_means, 
                mean(filter(df2, subject == levels(factor(column2))[i])$score))
        }
        for( i in c(1:length( levels(factor(column2)) )) ){
            # Get the ss1 portion
            ss1_vect <- c(ss1_vect, )
        }
        ss1 = sum(ss1_vect^2)
    }
}

## Hard coding

df2 <- data.frame(score = c(45, 70, 29, 15, 21, 40, 20, 30, 42, 65, 95, 80, 
                            70, 85, 73), 
                  subject = c(rep("Algebra", times = 5),
                              rep("Geometry", times = 4),
                              rep("Statistics", times = 6)))

temp_df <- expand.grid( "factors" = levels(factor(df2[ , 2])), 
                        "ss" = 0)
for( i in c(1:length( levels(factor(df2[ , 2])) )) ){
    subset <- filter(df2, subject == levels(factor(df2[ , 2]))[i] )
    subset_mean <- mean(subset[ , 1])
    sum_value = sum((subset[ , 1] - subset_mean)^2)
    temp_df$ss[i] <- sum_value
}

ss2 <- sum((df2[ , 1] - mean(df2[ , 1]))^2)

ss1 <- sum(temp_df$ss)

correlation_value <- sqrt( (ss2 - sum(temp_df$ss)) / ss2)

correlation_value

## end

skrt <- expand.grid( "factors" = levels(factor(df2[ , 2])), "ss1" = 0 )

sum(ss1)

d1 <- filter(df2, subject == "Algebra")
ss1 <- c(ss1, sum((d1$score - mean(d1$score))^2))

## End hard coding

# SS1 values
# 1952 for algebra
# 308 for geometry
# 600 for statistics
# adds up to 2860

# SS2 should be 9640

## Actual implementation

cor_ratio <- function(column1, column2){
    # Some assumptions
    # This function assumes no NA's, and that the rows of both columns are
    # in correct orders
    
    # If the order of the column classes are factor first, then use
    # the same function but swap the columns
    if(class(column1) == "factor" & 
       (class(column2) == "numeric" | class(column2) == "integer")){
        cor_ratio(column2, column1)
    }
    # If the columns types are in the correct order
    else if( (class(column1) == "numeric" | class(column1) == "integer") &
        class(column2) == "factor"){
            # Create a temporary dataframe to store columns for filter function
            temp_df <- data.frame("score" = column1,
                                  "subject" = column2)
            
            # Create a dataframe to store sum of squares of category
            # observation minus the category mean
            ss_df <- expand.grid( "factors" = levels(factor(column2)),
                                    "ss" = 0)
            for( i in c(1:length( levels(factor(column2)) )) ){
                subset <- filter(temp_df, 
                                 subject == levels(factor(column2))[i] )
                subset_mean <- mean(subset[ , 1])
                sum_value = sum((subset[ , 1] - subset_mean)^2)
                ss_df$ss[i] <- sum_value
            }
            # Remove variables that are no longer needed
            rm(subset, subset_mean, sum_value)
            
            # Assigning variables for these sums of squares for debugging
            ss1 <- sum(ss_df$ss)
            ss2 <- sum( (temp_df$score - mean(temp_df$score))^2 )
            
            correlation_value <- sqrt( (ss2 - sum(ss_df$ss)) / ss2)
            
            # Removing variables that are no longer needed
            rm(temp_df, ss1, ss2)
            
            return(correlation_value)
        }
    else{ # Error message if the incorrect inputs are given
        return("Error! This function only accepts one vector of class 'numeric'
               and one vector of class 'factor'.")
    }
}

cor_ratio(cd$gender, cd$tenure)

# Wikipedia example
df2 <- data.frame(score = c(45, 70, 29, 15, 21, 40, 20, 30, 42, 65, 95, 80, 70, 85, 73), 
                  subject = c(rep("Algebra", times = 5),
                              rep("Geometry", times = 4),
                              rep("Statistics", times = 6)
                              )
                  )

# Also testing that the ordering if/else statements are working
cor_ratio(df2$score, df2$subject)
cor_ratio(df2$subject, df2$score)

```


Heatmap
```{r}
# Heatmap code from the link below
# http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization
ggplot(data = cd.cor, aes(x = Column_1, y = Column_2, fill = Corr)) +
    geom_tile(color = "black") +
    scale_fill_gradient2(low = "black", high = "white", mid = "red",
                         midpoint = 0.5, limit = c(0, 1), space = "Lab",
                         name = "Correlation") +
    theme_minimal() + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
        coord_fixed()
```




