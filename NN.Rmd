---
title: "Churn analysis with neuralnet"
author: "Jackie Lu"
date: '2019-11-10'
header-includes:
  - \usepackage{latexsym,graphicx}
  - \usepackage{xcolor}
---
\definecolor{mylightgray}{RGB}{215, 215, 215}
\color{mylightgray}
\definecolor{mydarkgray}{RGB}{45, 45, 45}
\pagecolor{mydarkgray}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Info:
```{r}
# Link to the article that informed this code
# https://www.datacamp.com/community/tutorials/neural-network-models-r
```

Example
```{r}
library(neuralnet)
library(dplyr)

# creating training data set
TKS1 = c(20, 10, 30, 20, 80, 30)
CSS1 = c(90, 20, 40, 50, 50, 80)
Placed1 = c(1, 0, 0, 0, 1, 1)

# Here, you will combine multiple columns or features into a single set of data
df1 = data.frame(TKS1, CSS1, Placed1)

# Fitting the neural network
nn1 <- neuralnet(Placed1 ~ TKS1 + CSS1, data = df1, hidden = 3, act.fct = "logistic", linear.output = F)

# Plotting the neural network
plot(nn1)

# Creating a test set
TKS1 = c(30, 40, 85)
CSS1 = c(85, 50, 40)
test1 <- data.frame(TKS1, CSS1)

# Predict 'Placed1'
Predict1 = neuralnet::compute(nn1, test1)
Predict1$net.result

# Converting probabilities into binary placed or not
prob1 <- Predict1$net.result
(pred1 <- ifelse(prob1 > 0.5, yes = 1, no = 0))
```

**Trying neural networks with churn data**

*Cleaning the data*
```{r}
# If not done already
# library(neuralnet)
# library(dplyr)
library(purrr)

# Load the data
cd1 <- read.csv(file = "Churn.csv", header = TRUE, sep = ",", 
                stringsAsFactors = F)

# Edit column names so that they are all lowercase
colnames(cd1) <- map(colnames(cd1), tolower)

for( # Loop through every column in cd1
    i in c( 1:length(colnames(cd1)) )
){
    if( # Check that the column has 2 levels and that they contain 0 and 1
        (length(levels(factor( cd1[[ colnames(cd1)[i] ]] )) ) == 2) &
        (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "0" |
         levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "0") &
        (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "1" |
         levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "1")
    ){ # Turn the column into a logical column of TRUE's and FALSE's
      cd1[[ colnames(cd1)[i] ]] <- as.logical(cd1[[ colnames(cd1)[i] ]])  
    }
    else if( # If there are three levels in the column
        length(levels(factor( cd1[[ colnames(cd1)[i] ]] )) ) == 3
    ){
        if( # Check that Yes and No are two of the factors
            (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "Yes" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "Yes" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[3] == "Yes") &
            (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "No" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "No" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[3] == "No")
        ){ # Convert Yes's to TRUE and everything else to FALSE
            cd1[[ colnames(cd1)[i] ]] <- 
                ifelse(cd1[[ colnames(cd1)[i] ]] == "Yes", yes = T, no = F)
        } # This assumes that the third level is also no/FALSE
    }
    else if( # If there are two levels in the column
        length(levels(factor( cd1[[ colnames(cd1)[i] ]] )) ) == 2
    ){
        if( # Check that the factors are Yes or No
            (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "Yes" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "Yes") &
            (levels(factor( cd1[[ colnames(cd1)[i] ]] ))[1] == "No" |
             levels(factor( cd1[[ colnames(cd1)[i] ]] ))[2] == "No")
        ){
            cd1[[ colnames(cd1)[i] ]] <- 
                ifelse(cd1[[ colnames(cd1)[i] ]] == "Yes", yes = T, no = F)
        }
    }
}

# Splitting internet service into fiber optic and DSL
cd1 <- mutate(cd1, fiberoptic = ifelse(internetservice == "Fiber optic", 
                                       yes = T, no = F))
cd1 <- mutate(cd1, dsl = ifelse(internetservice == "DSL", yes = T, no = F))
```

I can't get this function to work
```{r}
binarize <- function(df1){
        for(
        i in c( 1:length(colnames(df1)) )
    ){
        if(
            (levels(factor( df1[[ colnames(df1)[i] ]] ))[1] == "0" |
             levels(factor( df1[[ colnames(df1)[i] ]] ))[2] == "0") &
            (levels(factor( df1[[ colnames(df1)[i] ]] ))[1] == "1" |
             levels(factor( df1[[ colnames(df1)[i] ]] ))[2] == "1")
        ){ # For some reason this line doesn't work
          df1[[ colnames(df1)[i] ]] <- as.logical(df1[[ colnames(df1)[i] ]])  
        }
    }
}
# Use 'binarize(cd1)' to try this function
```





